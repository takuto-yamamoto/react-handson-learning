# メモ

- fetch の送信

  - `JSON.stringify` でオブジェクトを文字列化する
  - ファイルアップロード時は multipart/form-data
    - FormData オブジェクトにデータを append する必要がある
  - 認証情報などは headers に追加される
    - Authorization: 認証トークンヘッダ

- データの保存

  - localStrage
    - 同一オリジンであれば異なるページやタブから閲覧可能
    - ブラウザのキャッシュ/データがクリアされるまで永続
  - sessionStrage:
    - ページ遷移では継続、別タブや別ウィンドウでは新しいセッション
    - タブが閉じるとデータはクリアされる
  - JSON API
    - parse/stringify と strageAPI の getItem/setItem
      - 同期処理なのでパフォーマンス低下の要因となりうる
  - localStrage のキャッシュしどころ
    - アプリケーションの複雑性が増すので、使い所に注意
    - HTTP キャッシュが確実には使用できない場合などに使用
    - `Cache-Contral: max-age=<有効時間>`ヘッダをレスポンスヘッダにつければ OK

- レンダープロップ

  - コンポーネントのプロパティのうち、子コンポーネントで描画されるもの
  - エラー時のメッセージやレンダリングロジックを外出しすることで、抽象的かつ汎用的なコンポーネントとなる
  - 当然汎用性は正義ではないので注意

- 仮想リスト

  - 大きなデータを扱う場合、全てをレンダリングすることはできない
  - 一部をマウントして不要な部分をアンマウントする、を繰り返すことで、使用リソースを常に一定にする（ジェネレータ方式）
  - 一から実装するのは手間なのでライブラリを使用する（react-window や react-virtualized）

- useFetch フック

  - Promise の返り値に対応する 3 つの値(loading, data, error) をステートとしてもつフック
  - 引数として URI を受け取り、それを useEffect の依存先に設定することで、URI が変更になるたびに fetch がキックされる

- Fetch コンポーネント

  - データ/ロジック/UI をまとめてコンポーネント化する
  - fetch の結果描画まで含めてコンポーネント化し、3 パターンの renderProp を渡す(初期値も設定する)
  - 抽象化レイヤーが複雑化を招くこともあるので注意

- 複数のリクエストを取り扱う

  - ウォーターフォールリクエスト
    - 逐次的に処理する
    - リクエスト A に成功した場合、リクエスト B は実行されない
  - 並列リクエスト
    - 同じタイミングでトリガーされ並列で処理される
  - WF リクエストと並列リクエストを使いこなすことが重要
  - 情報が既にあるならば並列リクエスト、揃ってないなら待機して WF リクエスト
    - 情報に相当するステートに && してコンポーネント描画をトリガーしてもいい

- リクエストのキャンセル

  - リクエスト中に、レスポンスが更新する予定の state を持つコンポーネントがアンマウントされた場合はエラーになる
    - コンポーネントがマウントされてるかどうかをチェックするカスタムフックで回避することが可能
    - コンポーネント内で ref を定義し、useEffect のクリーンアップ(return 文)内で ref.current を false にする
    - ref はコンポーネントがアンマウントされても維持されるため、ref.current の値に応じて state の更新が制御可能になる

- GraphQL
  - WebAPI を宣言的に記述するための手法
  - 単一のエンドポイントに対して複数のクエリを使い分けてリクエストする
