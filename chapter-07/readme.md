## メモ

- useEffect

  - useEffect は React の副作用を扱うフック（ログ、アラートなどの同期 WebAPI など）
  - コンポーネントの描画が完了した後に呼び出される
    - データの更新 -> レンダリング -> 副作用 のループ
  - 依存配列
    - データの更新に対象依存先の更新が含まれない場合は、そのフックが skip される
  - return
    - コンポーネントがアンマウントされた時のクリーンアップ処理を記載可能
    - 例：ニュースフィードのアンサブスクライブによるメモリリークの回避
  - 依存関係が同じでも 1 つの useEffect には 1 処理の方が読みやすいので分割すべし
    - それらが一連の処理である場合はカスタムフックに切り出す
  - オブジェクトを依存関係に含める場合は中身が同じでも参照が変われば再度副作用がトリガーされるので注意
    - ステートが厳密等価であれば副作用は skip される
    - オブジェクトは再レンダリングの都度生成されるので、厳密等価にはならない
      - 回避方法 1: コンポーネント外部で初期化する
      - 回避方法 2: 不可能な場合は useMemo や useCallback でメモ化する

- useLayoutEffect

  - 描画より前（useEffect より前）に呼び出されるフック
  - ユースケース例
    - ウィンドウサイズに応じてコンポーネントサイズを変更したい
    - マウスの位置に応じてコンポーネントの位置を変更したい

- フックのルール

  - コンポーネントのスコープかつトップレベルで実行する
  - 複数のフックに分割する
  - ルール違反検出は ESLint のプラグインで可能(CRA デフォ)

- useReducer

  - type で switch したい時以外でも、基本的に state に対して特定の操作しかしない場合は reducer を検討する

- React のパフォーマンスチューニング
  - 不要なレンダリングを抑えることがメイン(memo, useMemo, useCallback)
  - memo はコンポーネントのメモ化(コンポーネントは純粋関数である必要がある)
    - 第二引数は predicate(コンポーネント再描画を抑止する場合に true を返す cb 関数)
  - いつパフォーマンスチューニングを行うか
    - 乱用はしない！（元々の React のパフォーマンスが良いため）
    - フロー
      - レンダリングに時間がかかっている場所を確認(UX 確認)
      - React Developer Tools の Profiler で時間のかかっている処理(コンポーネント)を計測
      - リグレッション検出のためにこまめに単体テストしつつ memo などを活用して修正
